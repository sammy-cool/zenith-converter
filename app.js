const express = require("express");
const multer = require("multer");
const fs = require("fs-extra");
const path = require("path");
const AdmZip = require("adm-zip");
const winston = require("winston");
const PDFDocument = require("pdfkit");

// --- LOGGER ---
const logger = winston.createLogger({
  level: "info",
  format: winston.format.combine(
    winston.format.timestamp(),
    winston.format.printf(
      ({ timestamp, level, message }) =>
        `[${timestamp}] ${level.toUpperCase()}: ${message}`,
    ),
  ),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: "zenith.log" }),
  ],
});

const app = express();
// PRESERVE ORIGINAL FILENAME
const upload = multer({ dest: "uploads/" });

app.use(express.json());

const jobs = {};

// --- SSE ENDPOINT ---
app.get("/progress/:jobId", (req, res) => {
  res.setHeader("Content-Type", "text/event-stream");
  res.setHeader("Cache-Control", "no-cache");
  res.setHeader("Connection", "keep-alive");

  const checkInterval = setInterval(() => {
    const job = jobs[req.params.jobId];
    if (job) {
      res.write(`data: ${JSON.stringify(job)}\n\n`);
      if (job.status === "completed" || job.status === "failed") {
        clearInterval(checkInterval);
        res.end();
        setTimeout(() => {
          if (jobs[req.params.jobId]) delete jobs[req.params.jobId];
        }, 600000);
      }
    }
  }, 500);
});

// --- CONVERSION ENDPOINT ---
app.post("/convert", upload.single("zipfile"), async (req, res) => {
  if (!req.file) return res.status(400).send("No file uploaded");

  const jobId = Date.now().toString();
  const zipPath = req.file.path;

  // USE ORIGINAL NAME for PDF
  // We strip the .zip extension and sanitize special characters
  let originalName = req.file.originalname
    .replace(/\.zip$/i, "")
    .replace(/[^a-zA-Z0-9_\-\.]/g, "_");
  if (!originalName) originalName = "Project_Export";

  let userExclusions = { extensions: [], folders: [] };
  try {
    if (req.body.exclusions) userExclusions = JSON.parse(req.body.exclusions);
  } catch (e) {
    logger.error("Exclusion parse error");
  }

  jobs[jobId] = {
    status: "processing",
    percent: 0,
    message: "Initializing...",
    pdfName: `${originalName}.pdf`, // Tells frontend the real name
  };

  res.json({ jobId });

  // Run async to not block event loop
  await processZipV8(jobId, zipPath, userExclusions, originalName);
});

// --- V8 ENGINE ---
async function processZipV8(jobId, zipPath, exclusions, originalName) {
  const workDir = path.join(__dirname, "temp_extracted", jobId);
  const pdfName = `${originalName}.pdf`;
  const finalPdfPath = path.join(__dirname, "public", pdfName);

  try {
    // 1. EXTRACT
    jobs[jobId].message = "Extracting Archive...";
    const zip = new AdmZip(zipPath);
    zip.extractAllTo(workDir, true);

    // 2. SCAN & FILTER (Deep Check)
    const getFiles = (dir) => {
      let results = [];
      const list = fs.readdirSync(dir);
      for (const file of list) {
        const fullPath = path.join(dir, file);
        const relPath = path.relative(workDir, fullPath).replace(/\\/g, "/");

        // DEEP EXCLUSION
        // Split path: "server/node_modules/pkg" -> ["server", "node_modules", "pkg"]
        const pathSegments = relPath.split("/");

        // If ANY part of the path is in the exclusion list, skip it.
        const isExcluded = pathSegments.some((seg) =>
          exclusions.folders.includes(seg),
        );

        if (isExcluded) continue;

        const ext = path.extname(file).toLowerCase();
        if (exclusions.extensions.includes(ext)) continue;

        if (fs.statSync(fullPath).isDirectory()) {
          results = results.concat(getFiles(fullPath));
        } else {
          results.push(fullPath);
        }
      }
      return results;
    };

    const allFiles = getFiles(workDir);
    logger.info(`Job ${jobId}: Found ${allFiles.length} files`);

    // 3. SETUP PDF
    const doc = new PDFDocument({
      autoFirstPage: false,
      bufferPages: true,
      margin: 40,
    });
    const writeStream = fs.createWriteStream(finalPdfPath);
    doc.pipe(writeStream);

    // [FEATURE: COVER PAGE] - Adds "Enterprise" feel
    doc.addPage();
    doc.rect(0, 0, 600, 900).fill("#1a1a1a"); // Dark Background
    doc
      .fillColor("#ffffff")
      .fontSize(30)
      .font("Helvetica-Bold")
      .text(originalName, 50, 300, { align: "center" });
    doc
      .fontSize(14)
      .font("Helvetica")
      .text(`Generated by ansh.Priyanshu`, 50, 350, {
        align: "center",
        color: "#888888",
      });
    doc.fontSize(12).text(new Date().toDateString(), 50, 380, {
      align: "center",
      color: "#666666",
    });

    // 4. PRE-ALLOCATE INDEX PAGES
    // Approx 35 lines per page.
    const requiredIndexPages = Math.ceil(allFiles.length / 35) + 1;
    jobs[jobId].message = "Allocating Index...";

    for (let k = 0; k < requiredIndexPages; k++) {
      doc.addPage(); // Reserve these pages (e.g., Page 2, 3, 4)
    }

    if (requiredIndexPages > 0) doc.addPage(); // Move to Page 5 for Content

    // 5. RENDER CONTENT
    const tocEntries = [];

    for (let i = 0; i < allFiles.length; i++) {
      const filePath = allFiles[i];
      const relPath = path.relative(workDir, filePath).replace(/\\/g, "/");
      const safeId = `dest_${i}`;

      if (i > 0) doc.addPage();
      const currentPageNum = doc.bufferedPageRange().count;
      doc.addNamedDestination(safeId);
      tocEntries.push({ title: relPath, dest: safeId, page: currentPageNum });

      // File Header
      doc.rect(40, 40, 530, 25).fill("#e6f0ff").stroke();
      doc
        .fillColor("#0052cc")
        .fontSize(12)
        .font("Helvetica-Bold")
        .text(relPath, 50, 48);
      doc.moveDown(2);

      // File Content
      try {
        const buffer = fs.readFileSync(filePath);
        const isBinary = buffer.slice(0, 1000).includes(0);

        if (isBinary) {
          doc
            .fillColor("#cc0000")
            .fontSize(10)
            .font("Helvetica-Oblique")
            .text("[Binary File Omitted]");
        } else {
          let content = buffer.toString("utf8").slice(0, 100000); // 100KB Limit
          content = content.replace(
            /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x9F]/g,
            "",
          );
          const lines = content.split(/\r?\n/);
          doc.fontSize(9).font("Courier");

          for (let j = 0; j < lines.length; j++) {
            const line = lines[j];
            const lineNum = (j + 1).toString();
            const rowHeight = Math.max(
              doc.heightOfString(line, { width: 480 }),
              12,
            );

            if (doc.y + rowHeight > doc.page.height - 50) doc.addPage();

            const currentY = doc.y;
            // Gutter (Gray Bar)
            doc.rect(40, currentY, 35, rowHeight).fillColor("#f5f5f5").fill();
            // Line Number
            doc
              .fillColor("#999999")
              .text(lineNum, 42, currentY + 2, { width: 30, align: "right" });
            // Code Text
            doc
              .fillColor("#000000")
              .text(line, 85, currentY + 2, { width: 480, align: "left" });

            doc.x = 40;
          }
        }
      } catch (err) {}

      if (i % 10 === 0) {
        jobs[jobId].percent = Math.floor((i / allFiles.length) * 80);
        jobs[jobId].message = `Processing: ${path.basename(relPath)}`;
        if (global.gc) global.gc(); // Manual Garbage Collection for Low RAM
      }
    }

    // 6. WRITE INDEX
    jobs[jobId].message = "Writing Index...";

    // Go to Page 1 (The first reserved page after Cover)
    let indexPageIndex = 1;
    doc.switchToPage(indexPageIndex);
    doc.y = 50; //Reset Cursor to Top

    doc.rect(0, 0, 600, 800).fill("white"); // Clear background
    doc
      .fillColor("#000000")
      .fontSize(20)
      .font("Helvetica-Bold")
      .text("INDEX", 50, 50, { align: "center" });
    doc.moveDown(2);
    doc.fontSize(10).font("Helvetica");

    for (const entry of tocEntries) {
      // Check if we reached bottom of page
      if (doc.y > 700) {
        indexPageIndex++;
        if (indexPageIndex <= requiredIndexPages) {
          doc.switchToPage(indexPageIndex);
          doc.rect(0, 0, 600, 800).fill("white");
          doc.y = 50; // Reset Cursor again for new page
        } else {
          doc.addPage(); // Fallback
          doc.y = 50;
        }
      }

      // Link
      doc.fillColor("#0052cc").text(entry.title, {
        goTo: entry.dest,
        indent: 20,
        width: 450,
        continued: true,
        underline: true,
      });
      // Page Number
      doc
        .fillColor("#000000")
        .text(entry.page.toString(), { align: "right", underline: false });
      doc.moveDown(0.5);
    }

    doc.end();
    await new Promise((resolve) => writeStream.on("finish", resolve));

    jobs[jobId].status = "completed";
    jobs[jobId].percent = 100;
    jobs[jobId].downloadUrl = `/${pdfName}`;
    jobs[jobId].message = "Done!";
  } catch (error) {
    logger.error(`Job failed: ${error.message}`);
    jobs[jobId].status = "failed";
    jobs[jobId].message = "Error: " + error.message;
  } finally {
    try {
      if (await fs.pathExists(workDir)) await fs.remove(workDir);
      if (await fs.pathExists(zipPath)) await fs.unlink(zipPath);
    } catch (e) {}
  }
}

app.get("/health", (req, res) => {
  const timestamp = new Date().toISOString();
  const additionalText = "Zenith is UP!";
  const responseText = `OK - ${timestamp} - ${additionalText}`;
  res.send(responseText);
});

app.get("/", (req, res) => {
  res.sendFile(path.join(__dirname, "public", "index.html"));
  logger.info("Home Page");
});
app.use(express.static("public"));

const PORT = process.env.PORT || 3999;
app.listen(PORT, () =>
  logger.info(`Zenith V8 (Low RAM Mode) running on ${PORT}`),
);
